// Code generated by girgen. DO NOT EDIT.

package adw

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #include <stdlib.h>
// #include <adwaita.h>
// #include <glib-object.h>
// extern void _gotk4_adw1_SpinRow_ConnectWrapped(gpointer, guintptr);
// extern gboolean _gotk4_adw1_SpinRow_ConnectOutput(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeSpinRow = coreglib.Type(C.adw_spin_row_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSpinRow, F: marshalSpinRow},
	})
}

// SpinRowOverrides contains methods that are overridable.
type SpinRowOverrides struct {
}

func defaultSpinRowOverrides(v *SpinRow) SpinRowOverrides {
	return SpinRowOverrides{}
}

// SpinRow: actionrow with an embedded spin button.
//
// <picture> <source srcset="spin-row-dark.png" media="(prefers-color-scheme:
// dark)"> <img src="spin-row.png" alt="spin-row"> </picture>
//
// Example of an AdwSpinRow UI definition:
//
//	<object class="AdwSpinRow">
//	  <property name="title" translatable="yes">Spin Row</property>
//	  <property name="adjustment">
//	    <object class="GtkAdjustment">
//	      <property name="lower">0</property>
//	      <property name="upper">100</property>
//	      <property name="value">50</property>
//	      <property name="page-increment">10</property>
//	      <property name="step-increment">1</property>
//	    </object>
//	  </property>
//	</object>
//
// See gtk.SpinButton for details.
//
// # CSS nodes
//
// AdwSpinRow has the same structure as actionrow, as well as the .spin style
// class on the main node.
type SpinRow struct {
	_ [0]func() // equal guard
	ActionRow

	*coreglib.Object
	gtk.EditableTextWidget
}

var (
	_ coreglib.Objector = (*SpinRow)(nil)
	_ gtk.Widgetter     = (*SpinRow)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SpinRow, *SpinRowClass, SpinRowOverrides](
		GTypeSpinRow,
		initSpinRowClass,
		wrapSpinRow,
		defaultSpinRowOverrides,
	)
}

func initSpinRowClass(gclass unsafe.Pointer, overrides SpinRowOverrides, classInitFunc func(*SpinRowClass)) {
	if classInitFunc != nil {
		class := (*SpinRowClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSpinRow(obj *coreglib.Object) *SpinRow {
	return &SpinRow{
		ActionRow: ActionRow{
			PreferencesRow: PreferencesRow{
				ListBoxRow: gtk.ListBoxRow{
					Widget: gtk.Widget{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
						Object: obj,
						Accessible: gtk.Accessible{
							Object: obj,
						},
						Buildable: gtk.Buildable{
							Object: obj,
						},
						ConstraintTarget: gtk.ConstraintTarget{
							Object: obj,
						},
					},
					Object: obj,
					Actionable: gtk.Actionable{
						Widget: gtk.Widget{
							InitiallyUnowned: coreglib.InitiallyUnowned{
								Object: obj,
							},
							Object: obj,
							Accessible: gtk.Accessible{
								Object: obj,
							},
							Buildable: gtk.Buildable{
								Object: obj,
							},
							ConstraintTarget: gtk.ConstraintTarget{
								Object: obj,
							},
						},
					},
				},
			},
		},
		Object: obj,
		EditableTextWidget: gtk.EditableTextWidget{
			Widget: gtk.Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: gtk.Accessible{
					Object: obj,
				},
				Buildable: gtk.Buildable{
					Object: obj,
				},
				ConstraintTarget: gtk.ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalSpinRow(p uintptr) (interface{}, error) {
	return wrapSpinRow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectOutput is emitted to tweak the formatting of the value for display.
//
// See gtk.SpinButton::output.
func (self *SpinRow) ConnectOutput(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "output", false, unsafe.Pointer(C._gotk4_adw1_SpinRow_ConnectOutput), f)
}

// ConnectWrapped is emitted right after the spinbutton wraps.
//
// See gtk.SpinButton::wrapped.
func (self *SpinRow) ConnectWrapped(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "wrapped", false, unsafe.Pointer(C._gotk4_adw1_SpinRow_ConnectWrapped), f)
}

// NewSpinRow creates a new AdwSpinRow.
//
// The function takes the following parameters:
//
//   - adjustment (optional) that this spin row should use.
//   - climbRate: rate the value changes when holding a button or key.
//   - digits: number of decimal places to display.
//
// The function returns the following values:
//
//   - spinRow: newly created AdwSpinRow.
func NewSpinRow(adjustment *gtk.Adjustment, climbRate float64, digits uint) *SpinRow {
	var _arg1 *C.GtkAdjustment // out
	var _arg2 C.double         // out
	var _arg3 C.guint          // out
	var _cret *C.GtkWidget     // in

	if adjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	}
	_arg2 = C.double(climbRate)
	_arg3 = C.guint(digits)

	_cret = C.adw_spin_row_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(adjustment)
	runtime.KeepAlive(climbRate)
	runtime.KeepAlive(digits)

	var _spinRow *SpinRow // out

	_spinRow = wrapSpinRow(coreglib.Take(unsafe.Pointer(_cret)))

	return _spinRow
}

// NewSpinRowWithRange creates a new AdwSpinRow with the given properties.
//
// This is a convenience constructor that allows creation of a numeric
// AdwSpinRow without manually creating an adjustment. The value is initially
// set to the minimum value and a page increment of 10 * step is the default.
// The precision of the spin row is equivalent to the precisions of step.
//
// ::: note The way in which the precision is derived works best if step is a
// power of ten. If the resulting precision is not suitable for your needs,
// use spinrow.SetDigits to correct it.
//
// The function takes the following parameters:
//
//   - min: minimum allowable value.
//   - max: maximum allowable value.
//   - step: increment added or subtracted by spinning the widget.
//
// The function returns the following values:
//
//   - spinRow: new AdwSpinRow.
func NewSpinRowWithRange(min, max, step float64) *SpinRow {
	var _arg1 C.double     // out
	var _arg2 C.double     // out
	var _arg3 C.double     // out
	var _cret *C.GtkWidget // in

	_arg1 = C.double(min)
	_arg2 = C.double(max)
	_arg3 = C.double(step)

	_cret = C.adw_spin_row_new_with_range(_arg1, _arg2, _arg3)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)
	runtime.KeepAlive(step)

	var _spinRow *SpinRow // out

	_spinRow = wrapSpinRow(coreglib.Take(unsafe.Pointer(_cret)))

	return _spinRow
}

// Configure changes the properties of an existing spin row.
//
// The adjustment, climb rate, and number of decimal places are updated
// accordingly.
//
// The function takes the following parameters:
//
//   - adjustment (optional) that this spin row should use.
//   - climbRate: new climb rate.
//   - digits: number of decimal places to display.
func (self *SpinRow) Configure(adjustment *gtk.Adjustment, climbRate float64, digits uint) {
	var _arg0 *C.AdwSpinRow    // out
	var _arg1 *C.GtkAdjustment // out
	var _arg2 C.double         // out
	var _arg3 C.guint          // out

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if adjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	}
	_arg2 = C.double(climbRate)
	_arg3 = C.guint(digits)

	C.adw_spin_row_configure(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(adjustment)
	runtime.KeepAlive(climbRate)
	runtime.KeepAlive(digits)
}

// Adjustment gets the adjustment that holds the value for the spin row.
//
// The function returns the following values:
//
//   - adjustment that holds the spin row's value.
func (self *SpinRow) Adjustment() *gtk.Adjustment {
	var _arg0 *C.AdwSpinRow    // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_spin_row_get_adjustment(_arg0)
	runtime.KeepAlive(self)

	var _adjustment *gtk.Adjustment // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_adjustment = &gtk.Adjustment{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		}
	}

	return _adjustment
}

// ClimbRate gets the acceleration rate when you hold down a button or key.
//
// The function returns the following values:
//
//   - gdouble: acceleration rate when you hold down a button or key.
func (self *SpinRow) ClimbRate() float64 {
	var _arg0 *C.AdwSpinRow // out
	var _cret C.double      // in

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_spin_row_get_climb_rate(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Digits gets the number of decimal places to display.
//
// The function returns the following values:
//
//   - guint: number of decimal places to display.
func (self *SpinRow) Digits() uint {
	var _arg0 *C.AdwSpinRow // out
	var _cret C.guint       // in

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_spin_row_get_digits(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Numeric gets whether non-numeric characters should be ignored.
//
// The function returns the following values:
//
//   - ok: whether non-numeric characters should be ignored.
func (self *SpinRow) Numeric() bool {
	var _arg0 *C.AdwSpinRow // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_spin_row_get_numeric(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SnapToTicks gets whether invalid values are snapped to nearest step
// increment.
//
// The function returns the following values:
//
//   - ok: whether invalid values are snapped to the nearest step increment.
func (self *SpinRow) SnapToTicks() bool {
	var _arg0 *C.AdwSpinRow // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_spin_row_get_snap_to_ticks(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UpdatePolicy gets the policy for updating the spin row.
//
// The function returns the following values:
//
//   - spinButtonUpdatePolicy: policy for updating the spin row.
func (self *SpinRow) UpdatePolicy() gtk.SpinButtonUpdatePolicy {
	var _arg0 *C.AdwSpinRow               // out
	var _cret C.GtkSpinButtonUpdatePolicy // in

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_spin_row_get_update_policy(_arg0)
	runtime.KeepAlive(self)

	var _spinButtonUpdatePolicy gtk.SpinButtonUpdatePolicy // out

	_spinButtonUpdatePolicy = gtk.SpinButtonUpdatePolicy(_cret)

	return _spinButtonUpdatePolicy
}

// Value gets the current value.
//
// The function returns the following values:
//
//   - gdouble: current value.
func (self *SpinRow) Value() float64 {
	var _arg0 *C.AdwSpinRow // out
	var _cret C.double      // in

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_spin_row_get_value(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Wrap gets whether the spin row should wrap upon reaching its limits.
//
// The function returns the following values:
//
//   - ok: whether the spin row should wrap upon reaching its limits.
func (self *SpinRow) Wrap() bool {
	var _arg0 *C.AdwSpinRow // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_spin_row_get_wrap(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAdjustment sets the adjustment that holds the value for the spin row.
//
// The function takes the following parameters:
//
//   - adjustment (optional): adjustment.
func (self *SpinRow) SetAdjustment(adjustment *gtk.Adjustment) {
	var _arg0 *C.AdwSpinRow    // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if adjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	}

	C.adw_spin_row_set_adjustment(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(adjustment)
}

// SetClimbRate sets the acceleration rate when you hold down a button or key.
//
// The function takes the following parameters:
//
//   - climbRate: acceleration rate when you hold down a button or key.
func (self *SpinRow) SetClimbRate(climbRate float64) {
	var _arg0 *C.AdwSpinRow // out
	var _arg1 C.double      // out

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.double(climbRate)

	C.adw_spin_row_set_climb_rate(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(climbRate)
}

// SetDigits sets the number of decimal places to display.
//
// The function takes the following parameters:
//
//   - digits: number of decimal places to display.
func (self *SpinRow) SetDigits(digits uint) {
	var _arg0 *C.AdwSpinRow // out
	var _arg1 C.guint       // out

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(digits)

	C.adw_spin_row_set_digits(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(digits)
}

// SetNumeric sets whether non-numeric characters should be ignored.
//
// The function takes the following parameters:
//
//   - numeric: whether non-numeric characters should be ignored.
func (self *SpinRow) SetNumeric(numeric bool) {
	var _arg0 *C.AdwSpinRow // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if numeric {
		_arg1 = C.TRUE
	}

	C.adw_spin_row_set_numeric(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(numeric)
}

// SetRange sets the minimum and maximum allowable values for self.
//
// If the current value is outside this range, it will be adjusted to fit within
// the range, otherwise it will remain unchanged.
//
// The function takes the following parameters:
//
//   - min: minimum allowable value.
//   - max: maximum allowable value.
func (self *SpinRow) SetRange(min, max float64) {
	var _arg0 *C.AdwSpinRow // out
	var _arg1 C.double      // out
	var _arg2 C.double      // out

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.double(min)
	_arg2 = C.double(max)

	C.adw_spin_row_set_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)
}

// SetSnapToTicks sets whether invalid values are snapped to the nearest step
// increment.
//
// The function takes the following parameters:
//
//   - snapToTicks: whether invalid values are snapped to the nearest step
//     increment.
func (self *SpinRow) SetSnapToTicks(snapToTicks bool) {
	var _arg0 *C.AdwSpinRow // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if snapToTicks {
		_arg1 = C.TRUE
	}

	C.adw_spin_row_set_snap_to_ticks(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(snapToTicks)
}

// SetUpdatePolicy sets the policy for updating the spin row.
//
// The options are always, or only when the value is invalid.
//
// The function takes the following parameters:
//
//   - policy for updating the spin row.
func (self *SpinRow) SetUpdatePolicy(policy gtk.SpinButtonUpdatePolicy) {
	var _arg0 *C.AdwSpinRow               // out
	var _arg1 C.GtkSpinButtonUpdatePolicy // out

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkSpinButtonUpdatePolicy(policy)

	C.adw_spin_row_set_update_policy(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(policy)
}

// SetValue sets the current value.
//
// The function takes the following parameters:
//
//   - value: new value.
func (self *SpinRow) SetValue(value float64) {
	var _arg0 *C.AdwSpinRow // out
	var _arg1 C.double      // out

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.double(value)

	C.adw_spin_row_set_value(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(value)
}

// SetWrap sets whether the spin row should wrap upon reaching its limits.
//
// The function takes the following parameters:
//
//   - wrap: whether the spin row should wrap upon reaching its limits.
func (self *SpinRow) SetWrap(wrap bool) {
	var _arg0 *C.AdwSpinRow // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if wrap {
		_arg1 = C.TRUE
	}

	C.adw_spin_row_set_wrap(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(wrap)
}

// Update: manually force an update of the spin row.
func (self *SpinRow) Update() {
	var _arg0 *C.AdwSpinRow // out

	_arg0 = (*C.AdwSpinRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.adw_spin_row_update(_arg0)
	runtime.KeepAlive(self)
}
