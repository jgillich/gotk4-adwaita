// Code generated by girgen. DO NOT EDIT.

package adw

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #include <stdlib.h>
// #include <adwaita.h>
// #include <glib-object.h>
// extern void _gotk4_adw1_Dialog_ConnectClosed(gpointer, guintptr);
// extern void _gotk4_adw1_Dialog_ConnectCloseAttempt(gpointer, guintptr);
// extern void _gotk4_adw1_DialogClass_closed(AdwDialog*);
// extern void _gotk4_adw1_DialogClass_close_attempt(AdwDialog*);
// void _gotk4_adw1_Dialog_virtual_close_attempt(void* fnptr, AdwDialog* arg0) {
//   ((void (*)(AdwDialog*))(fnptr))(arg0);
// };
// void _gotk4_adw1_Dialog_virtual_closed(void* fnptr, AdwDialog* arg0) {
//   ((void (*)(AdwDialog*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeDialogPresentationMode = coreglib.Type(C.adw_dialog_presentation_mode_get_type())
	GTypeDialog                 = coreglib.Type(C.adw_dialog_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDialogPresentationMode, F: marshalDialogPresentationMode},
		coreglib.TypeMarshaler{T: GTypeDialog, F: marshalDialog},
	})
}

// DialogPresentationMode describes the available presentation modes for dialog.
//
// New values may be added to this enumeration over time.
//
// See dialog:presentation-mode.
type DialogPresentationMode C.gint

const (
	// DialogAuto: switch between ADW_DIALOG_FLOATING and
	// ADW_DIALOG_BOTTOM_SHEET depending on available size.
	DialogAuto DialogPresentationMode = iota
	// DialogFloating: present dialog as a centered floating window.
	DialogFloating
	// DialogBottomSheet: present dialog as a bottom sheet.
	DialogBottomSheet
)

func marshalDialogPresentationMode(p uintptr) (interface{}, error) {
	return DialogPresentationMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DialogPresentationMode.
func (d DialogPresentationMode) String() string {
	switch d {
	case DialogAuto:
		return "Auto"
	case DialogFloating:
		return "Floating"
	case DialogBottomSheet:
		return "BottomSheet"
	default:
		return fmt.Sprintf("DialogPresentationMode(%d)", d)
	}
}

// DialogOverrides contains methods that are overridable.
type DialogOverrides struct {
	CloseAttempt func()
	Closed       func()
}

func defaultDialogOverrides(v *Dialog) DialogOverrides {
	return DialogOverrides{
		CloseAttempt: v.closeAttempt,
		Closed:       v.closed,
	}
}

// Dialog: adaptive dialog container.
//
// <picture> <source srcset="dialog-floating-dark.png"
// media="(prefers-color-scheme: dark)"> <img src="dialog-floating.png"
// alt="dialog-floating"> </picture> <picture> <source
// srcset="dialog-bottom-dark.png" media="(prefers-color-scheme: dark)"> <img
// src="dialog-bottom.png" alt="dialog-bottom"> </picture>
//
// AdwDialog is similar to a window, but is shown within another window. It can
// be used with window and applicationwindow, use dialog.Present to show it.
//
// AdwDialog is not resizable. Use the dialog:content-width
// and dialog:content-height properties to set its size, or set
// dialog:follows-content-size to TRUE to make the dialog track the content's
// size as it changes. AdwDialog can never be larger than its parent window.
//
// AdwDialog can be presented as a centered floating window or a bottom
// sheet. By default it's automatic depending on the available size.
// dialog:presentation-mode can be used to change that.
//
// AdwDialog can be closed via dialog.Close.
//
// When presented as a bottom sheet, AdwDialog can also be closed via swiping it
// down.
//
// The dialog:can-close can be used to prevent closing. In that case,
// dialog::close-attempt gets emitted instead.
//
// Use dialog.ForceClose to close the dialog even when can-close is set to
// FALSE.
//
// # Header Bar Integration
//
// When placed inside an AdwDialog, headerbar will display the dialog
// title instead of window title. It will also adjust the decoration
// layout to ensure it always has a close button and nothing else. Set
// headerbar:show-start-title-buttons and headerbar:show-end-title-buttons to
// FALSE to remove it if it's unwanted.
//
// # Breakpoints
//
// AdwDialog can be used with breakpoint the same way as breakpointbin. Refer to
// that widget's documentation for details.
//
// Like AdwBreakpointBin, if breakpoints are used, AdwDialog doesn't have a
// minimum size, and gtk.Widget:width-request and gtk.Widget:height-request
// properties must be set manually.
type Dialog struct {
	_ [0]func() // equal guard
	gtk.Widget
}

var (
	_ gtk.Widgetter = (*Dialog)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Dialog, *DialogClass, DialogOverrides](
		GTypeDialog,
		initDialogClass,
		wrapDialog,
		defaultDialogOverrides,
	)
}

func initDialogClass(gclass unsafe.Pointer, overrides DialogOverrides, classInitFunc func(*DialogClass)) {
	pclass := (*C.AdwDialogClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeDialog))))

	if overrides.CloseAttempt != nil {
		pclass.close_attempt = (*[0]byte)(C._gotk4_adw1_DialogClass_close_attempt)
	}

	if overrides.Closed != nil {
		pclass.closed = (*[0]byte)(C._gotk4_adw1_DialogClass_closed)
	}

	if classInitFunc != nil {
		class := (*DialogClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDialog(obj *coreglib.Object) *Dialog {
	return &Dialog{
		Widget: gtk.Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: gtk.Accessible{
				Object: obj,
			},
			Buildable: gtk.Buildable{
				Object: obj,
			},
			ConstraintTarget: gtk.ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalDialog(p uintptr) (interface{}, error) {
	return wrapDialog(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCloseAttempt is emitted when the close button or shortcut is used,
// or dialog.Close is called while dialog:can-close is set to FALSE.
func (self *Dialog) ConnectCloseAttempt(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "close-attempt", false, unsafe.Pointer(C._gotk4_adw1_Dialog_ConnectCloseAttempt), f)
}

// ConnectClosed is emitted when the dialog is successfully closed.
func (self *Dialog) ConnectClosed(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "closed", false, unsafe.Pointer(C._gotk4_adw1_Dialog_ConnectClosed), f)
}

// NewDialog creates a new AdwDialog.
//
// The function returns the following values:
//
//   - dialog: new created AdwDialog.
func NewDialog() *Dialog {
	var _cret *C.AdwDialog // in

	_cret = C.adw_dialog_new()

	var _dialog *Dialog // out

	_dialog = wrapDialog(coreglib.Take(unsafe.Pointer(_cret)))

	return _dialog
}

// AddBreakpoint adds breakpoint to self.
//
// The function takes the following parameters:
//
//   - breakpoint to add.
func (self *Dialog) AddBreakpoint(breakpoint *Breakpoint) {
	var _arg0 *C.AdwDialog     // out
	var _arg1 *C.AdwBreakpoint // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwBreakpoint)(unsafe.Pointer(coreglib.InternObject(breakpoint).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(breakpoint).Native()))

	C.adw_dialog_add_breakpoint(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(breakpoint)
}

// Close attempts to close self.
//
// If the dialog:can-close property is set to FALSE, the dialog::close-attempt
// signal is emitted.
//
// See also: dialog.ForceClose.
//
// The function returns the following values:
//
//   - ok: whether self was successfully closed.
func (self *Dialog) Close() bool {
	var _arg0 *C.AdwDialog // out
	var _cret C.gboolean   // in

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_dialog_close(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForceClose closes self.
//
// Unlike dialog.Close, it succeeds even if dialog:can-close is set to FALSE.
func (self *Dialog) ForceClose() {
	var _arg0 *C.AdwDialog // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.adw_dialog_force_close(_arg0)
	runtime.KeepAlive(self)
}

// CanClose gets whether self can be closed.
//
// The function returns the following values:
//
//   - ok: whether the dialog can be closed.
func (self *Dialog) CanClose() bool {
	var _arg0 *C.AdwDialog // out
	var _cret C.gboolean   // in

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_dialog_get_can_close(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Child gets the child widget of self.
//
// The function returns the following values:
//
//   - widget (optional): child widget of self.
func (self *Dialog) Child() gtk.Widgetter {
	var _arg0 *C.AdwDialog // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_dialog_get_child(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// ContentHeight gets the height of the dialog's contents.
//
// The function returns the following values:
//
//   - gint: content height.
func (self *Dialog) ContentHeight() int {
	var _arg0 *C.AdwDialog // out
	var _cret C.int        // in

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_dialog_get_content_height(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ContentWidth gets the width of the dialog's contents.
//
// The function returns the following values:
//
//   - gint: content width.
func (self *Dialog) ContentWidth() int {
	var _arg0 *C.AdwDialog // out
	var _cret C.int        // in

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_dialog_get_content_width(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CurrentBreakpoint gets the current breakpoint.
//
// The function returns the following values:
//
//   - breakpoint (optional): current breakpoint.
func (self *Dialog) CurrentBreakpoint() *Breakpoint {
	var _arg0 *C.AdwDialog     // out
	var _cret *C.AdwBreakpoint // in

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_dialog_get_current_breakpoint(_arg0)
	runtime.KeepAlive(self)

	var _breakpoint *Breakpoint // out

	if _cret != nil {
		_breakpoint = wrapBreakpoint(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _breakpoint
}

// DefaultWidget gets the default widget for self.
//
// The function returns the following values:
//
//   - widget (optional): default widget.
func (self *Dialog) DefaultWidget() gtk.Widgetter {
	var _arg0 *C.AdwDialog // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_dialog_get_default_widget(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Focus gets the focus widget for self.
//
// The function returns the following values:
//
//   - widget (optional) focus widget.
func (self *Dialog) Focus() gtk.Widgetter {
	var _arg0 *C.AdwDialog // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_dialog_get_focus(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// FollowsContentSize gets whether to size content of self automatically.
//
// The function returns the following values:
//
//   - ok: whether to size content automatically.
func (self *Dialog) FollowsContentSize() bool {
	var _arg0 *C.AdwDialog // out
	var _cret C.gboolean   // in

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_dialog_get_follows_content_size(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PresentationMode gets presentation mode for self.
//
// The function returns the following values:
//
//   - dialogPresentationMode: presentation mode.
func (self *Dialog) PresentationMode() DialogPresentationMode {
	var _arg0 *C.AdwDialog                // out
	var _cret C.AdwDialogPresentationMode // in

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_dialog_get_presentation_mode(_arg0)
	runtime.KeepAlive(self)

	var _dialogPresentationMode DialogPresentationMode // out

	_dialogPresentationMode = DialogPresentationMode(_cret)

	return _dialogPresentationMode
}

// Title gets the title of self.
//
// The function returns the following values:
//
//   - utf8: title.
func (self *Dialog) Title() string {
	var _arg0 *C.AdwDialog // out
	var _cret *C.char      // in

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_dialog_get_title(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Present presents self within parent's window.
//
// If self is already shown, raises it to the top instead.
//
// If the window is an window or applicationwindow, the dialog will be shown
// within it. Otherwise, it will be a separate window.
//
// The function takes the following parameters:
//
//   - parent (optional): widget within the toplevel.
func (self *Dialog) Present(parent gtk.Widgetter) {
	var _arg0 *C.AdwDialog // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if parent != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	C.adw_dialog_present(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(parent)
}

// SetCanClose sets whether self can be closed.
//
// If set to FALSE, the close button, shortcuts and dialog.Close will result
// in dialog::close-attempt being emitted instead, and bottom sheet close swipe
// will be disabled. dialog.ForceClose still works.
//
// The function takes the following parameters:
//
//   - canClose: whether to allow closing.
func (self *Dialog) SetCanClose(canClose bool) {
	var _arg0 *C.AdwDialog // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if canClose {
		_arg1 = C.TRUE
	}

	C.adw_dialog_set_can_close(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(canClose)
}

// SetChild sets the child widget of self.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (self *Dialog) SetChild(child gtk.Widgetter) {
	var _arg0 *C.AdwDialog // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.adw_dialog_set_child(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// SetContentHeight sets the height of the dialog's contents.
//
// Set it to -1 to reset it to the content's natural height.
//
// See also: gtk.Window:default-height.
//
// The function takes the following parameters:
//
//   - contentHeight: content height.
func (self *Dialog) SetContentHeight(contentHeight int) {
	var _arg0 *C.AdwDialog // out
	var _arg1 C.int        // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(contentHeight)

	C.adw_dialog_set_content_height(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(contentHeight)
}

// SetContentWidth sets the width of the dialog's contents.
//
// Set it to -1 to reset it to the content's natural width.
//
// See also: gtk.Window:default-width.
//
// The function takes the following parameters:
//
//   - contentWidth: content width.
func (self *Dialog) SetContentWidth(contentWidth int) {
	var _arg0 *C.AdwDialog // out
	var _arg1 C.int        // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(contentWidth)

	C.adw_dialog_set_content_width(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(contentWidth)
}

// SetDefaultWidget sets the default widget for self.
//
// It's activated when the user presses Enter.
//
// The function takes the following parameters:
//
//   - defaultWidget (optional): default widget.
func (self *Dialog) SetDefaultWidget(defaultWidget gtk.Widgetter) {
	var _arg0 *C.AdwDialog // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if defaultWidget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(defaultWidget).Native()))
	}

	C.adw_dialog_set_default_widget(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(defaultWidget)
}

// SetFocus sets the focus widget for self.
//
// If focus is not the current focus widget, and is focusable, sets it as the
// focus widget for the dialog.
//
// If focus is NULL, unsets the focus widget for this dialog. To set the focus
// to a particular widget in the dialog, it is usually more convenient to use
// gtk.Widget.GrabFocus() instead of this function.
//
// The function takes the following parameters:
//
//   - focus (optional) widget.
func (self *Dialog) SetFocus(focus gtk.Widgetter) {
	var _arg0 *C.AdwDialog // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if focus != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(focus).Native()))
	}

	C.adw_dialog_set_focus(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(focus)
}

// SetFollowsContentSize sets whether to size content of self automatically.
//
// If set to TRUE, always use the content's natural size instead of
// dialog:content-width and dialog:content-height. If the content resizes,
// the dialog will immediately resize as well.
//
// See also: gtk.Window:resizable.
//
// The function takes the following parameters:
//
//   - followsContentSize: whether to size content automatically.
func (self *Dialog) SetFollowsContentSize(followsContentSize bool) {
	var _arg0 *C.AdwDialog // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if followsContentSize {
		_arg1 = C.TRUE
	}

	C.adw_dialog_set_follows_content_size(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(followsContentSize)
}

// SetPresentationMode sets presentation mode for self.
//
// When set to ADW_DIALOG_AUTO, the dialog appears as a bottom sheet when the
// following condition is met: max-width: 450px or max-height: 360px, and as a
// floating window otherwise.
//
// Set it to ADW_DIALOG_FLOATING or ADW_DIALOG_BOTTOM_SHEET to always present
// it a floating window or a bottom sheet respectively, regardless of available
// size.
//
// Presentation mode does nothing for dialogs presented as a window.
//
// The function takes the following parameters:
//
//   - presentationMode: new presentation mode.
func (self *Dialog) SetPresentationMode(presentationMode DialogPresentationMode) {
	var _arg0 *C.AdwDialog                // out
	var _arg1 C.AdwDialogPresentationMode // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwDialogPresentationMode(presentationMode)

	C.adw_dialog_set_presentation_mode(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(presentationMode)
}

// SetTitle sets the title of self.
//
// The function takes the following parameters:
//
//   - title: new title.
func (self *Dialog) SetTitle(title string) {
	var _arg0 *C.AdwDialog // out
	var _arg1 *C.char      // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	C.adw_dialog_set_title(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(title)
}

func (dialog *Dialog) closeAttempt() {
	gclass := (*C.AdwDialogClass)(coreglib.PeekParentClass(dialog))
	fnarg := gclass.close_attempt

	var _arg0 *C.AdwDialog // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(dialog).Native()))

	C._gotk4_adw1_Dialog_virtual_close_attempt(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(dialog)
}

func (dialog *Dialog) closed() {
	gclass := (*C.AdwDialogClass)(coreglib.PeekParentClass(dialog))
	fnarg := gclass.closed

	var _arg0 *C.AdwDialog // out

	_arg0 = (*C.AdwDialog)(unsafe.Pointer(coreglib.InternObject(dialog).Native()))

	C._gotk4_adw1_Dialog_virtual_closed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(dialog)
}
