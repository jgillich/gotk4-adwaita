// Code generated by girgen. DO NOT EDIT.

package adw

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #include <stdlib.h>
// #include <adwaita.h>
// #include <glib-object.h>
// extern void _gotk4_adw1_TabView_ConnectSetupMenu(gpointer, AdwTabPage*, guintptr);
// extern void _gotk4_adw1_TabView_ConnectPageReordered(gpointer, AdwTabPage*, gint, guintptr);
// extern void _gotk4_adw1_TabView_ConnectPageDetached(gpointer, AdwTabPage*, gint, guintptr);
// extern void _gotk4_adw1_TabView_ConnectPageAttached(gpointer, AdwTabPage*, gint, guintptr);
// extern void _gotk4_adw1_TabView_ConnectIndicatorActivated(gpointer, AdwTabPage*, guintptr);
// extern gboolean _gotk4_adw1_TabView_ConnectClosePage(gpointer, AdwTabPage*, guintptr);
// extern AdwTabView* _gotk4_adw1_TabView_ConnectCreateWindow(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeTabPage = coreglib.Type(C.adw_tab_page_get_type())
	GTypeTabView = coreglib.Type(C.adw_tab_view_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTabPage, F: marshalTabPage},
		coreglib.TypeMarshaler{T: GTypeTabView, F: marshalTabView},
	})
}

// TabPageOverrides contains methods that are overridable.
type TabPageOverrides struct {
}

func defaultTabPageOverrides(v *TabPage) TabPageOverrides {
	return TabPageOverrides{}
}

// TabPage: auxiliary class used by tabview.
type TabPage struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gtk.Accessible
}

var (
	_ coreglib.Objector = (*TabPage)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TabPage, *TabPageClass, TabPageOverrides](
		GTypeTabPage,
		initTabPageClass,
		wrapTabPage,
		defaultTabPageOverrides,
	)
}

func initTabPageClass(gclass unsafe.Pointer, overrides TabPageOverrides, classInitFunc func(*TabPageClass)) {
	if classInitFunc != nil {
		class := (*TabPageClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTabPage(obj *coreglib.Object) *TabPage {
	return &TabPage{
		Object: obj,
		Accessible: gtk.Accessible{
			Object: obj,
		},
	}
}

func marshalTabPage(p uintptr) (interface{}, error) {
	return wrapTabPage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Child gets the child of self.
//
// The function returns the following values:
//
//   - widget: child of self.
func (self *TabPage) Child() gtk.Widgetter {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_child(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gtk.Widgetter)
			return ok
		})
		rv, ok := casted.(gtk.Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// Icon gets the icon of self.
//
// The function returns the following values:
//
//   - icon (optional) of self.
func (self *TabPage) Icon() *gio.Icon {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.GIcon      // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_icon(_arg0)
	runtime.KeepAlive(self)

	var _icon *gio.Icon // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_icon = &gio.Icon{
				Object: obj,
			}
		}
	}

	return _icon
}

// IndicatorActivatable gets whether the indicator of self is activatable.
//
// The function returns the following values:
//
//   - ok: whether the indicator is activatable.
func (self *TabPage) IndicatorActivatable() bool {
	var _arg0 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_indicator_activatable(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IndicatorIcon gets the indicator icon of self.
//
// The function returns the following values:
//
//   - icon (optional): indicator icon of self.
func (self *TabPage) IndicatorIcon() *gio.Icon {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.GIcon      // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_indicator_icon(_arg0)
	runtime.KeepAlive(self)

	var _icon *gio.Icon // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_icon = &gio.Icon{
				Object: obj,
			}
		}
	}

	return _icon
}

// IndicatorTooltip gets the tooltip of the indicator icon of self.
//
// The function returns the following values:
//
//   - utf8: indicator tooltip of self.
func (self *TabPage) IndicatorTooltip() string {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.char       // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_indicator_tooltip(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Keyword gets the search keyword of self.
//
// The function returns the following values:
//
//   - utf8 (optional): search keyword of self.
func (self *TabPage) Keyword() string {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.char       // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_keyword(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// LiveThumbnail gets whether to live thumbnail is enabled self.
//
// The function returns the following values:
//
//   - ok: whether live thumbnail is enabled.
func (self *TabPage) LiveThumbnail() bool {
	var _arg0 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_live_thumbnail(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Loading gets whether self is loading.
//
// The function returns the following values:
//
//   - ok: whether self is loading.
func (self *TabPage) Loading() bool {
	var _arg0 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_loading(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NeedsAttention gets whether self needs attention.
//
// The function returns the following values:
//
//   - ok: whether self needs attention.
func (self *TabPage) NeedsAttention() bool {
	var _arg0 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_needs_attention(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Parent gets the parent page of self.
//
// See tabview.AddPage and tabview.ClosePage.
//
// The function returns the following values:
//
//   - tabPage (optional): parent page.
func (self *TabPage) Parent() *TabPage {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.AdwTabPage // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_parent(_arg0)
	runtime.KeepAlive(self)

	var _tabPage *TabPage // out

	if _cret != nil {
		_tabPage = wrapTabPage(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _tabPage
}

// Pinned gets whether self is pinned.
//
// See tabview.SetPagePinned.
//
// The function returns the following values:
//
//   - ok: whether self is pinned.
func (self *TabPage) Pinned() bool {
	var _arg0 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_pinned(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Selected gets whether self is selected.
//
// The function returns the following values:
//
//   - ok: whether self is selected.
func (self *TabPage) Selected() bool {
	var _arg0 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_selected(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ThumbnailXAlign gets the horizontal alignment of the thumbnail for self.
//
// The function returns the following values:
//
//   - gfloat: horizontal alignment.
func (self *TabPage) ThumbnailXAlign() float32 {
	var _arg0 *C.AdwTabPage // out
	var _cret C.float       // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_thumbnail_xalign(_arg0)
	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// ThumbnailYAlign gets the vertical alignment of the thumbnail for self.
//
// The function returns the following values:
//
//   - gfloat: vertical alignment.
func (self *TabPage) ThumbnailYAlign() float32 {
	var _arg0 *C.AdwTabPage // out
	var _cret C.float       // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_thumbnail_yalign(_arg0)
	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Title gets the title of self.
//
// The function returns the following values:
//
//   - utf8: title of self.
func (self *TabPage) Title() string {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.char       // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_title(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Tooltip gets the tooltip of self.
//
// The function returns the following values:
//
//   - utf8 (optional): tooltip of self.
func (self *TabPage) Tooltip() string {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.char       // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_tooltip(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// InvalidateThumbnail invalidates thumbnail for self.
//
// If an taboverview is open, the thumbnail representing self will be
// immediately updated. Otherwise it will be update when opening the overview.
//
// Does nothing if tabpage:live-thumbnail is set to TRUE.
//
// See also tabview.InvalidateThumbnails.
func (self *TabPage) InvalidateThumbnail() {
	var _arg0 *C.AdwTabPage // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.adw_tab_page_invalidate_thumbnail(_arg0)
	runtime.KeepAlive(self)
}

// SetIcon sets the icon of self.
//
// tabbar and taboverview display the icon next to the title, unless
// tabpage:loading is set to TRUE.
//
// AdwTabBar also won't show the icon if the page is pinned and
// [propertyTabPage:indicator-icon] is set.
//
// The function takes the following parameters:
//
//   - icon (optional) of self.
func (self *TabPage) SetIcon(icon gio.Iconner) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 *C.GIcon      // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if icon != nil {
		_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	}

	C.adw_tab_page_set_icon(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(icon)
}

// SetIndicatorActivatable sets whether the indicator of self is activatable.
//
// If set to TRUE, tabview::indicator-activated will be emitted when the
// indicator icon is clicked.
//
// If tabpage:indicator-icon is not set, does nothing.
//
// The function takes the following parameters:
//
//   - activatable: whether the indicator is activatable.
func (self *TabPage) SetIndicatorActivatable(activatable bool) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if activatable {
		_arg1 = C.TRUE
	}

	C.adw_tab_page_set_indicator_activatable(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(activatable)
}

// SetIndicatorIcon sets the indicator icon of self.
//
// A common use case is an audio or camera indicator in a web browser.
//
// tabbar will show it at the beginning of the tab, alongside icon representing
// tabpage:icon or loading spinner.
//
// If the page is pinned, the indicator will be shown instead of icon or
// spinner.
//
// taboverview will show it at the at the top part of the thumbnail.
//
// tabpage:indicator-tooltip can be used to set the tooltip on the indicator
// icon.
//
// If tabpage:indicator-activatable is set to TRUE, the indicator icon can act
// as a button.
//
// The function takes the following parameters:
//
//   - indicatorIcon (optional): indicator icon of self.
func (self *TabPage) SetIndicatorIcon(indicatorIcon gio.Iconner) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 *C.GIcon      // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if indicatorIcon != nil {
		_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(indicatorIcon).Native()))
	}

	C.adw_tab_page_set_indicator_icon(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(indicatorIcon)
}

// SetIndicatorTooltip sets the tooltip of the indicator icon of self.
//
// The tooltip can be marked up with the Pango text markup language.
//
// See tabpage:indicator-icon.
//
// The function takes the following parameters:
//
//   - tooltip: indicator tooltip of self.
func (self *TabPage) SetIndicatorTooltip(tooltip string) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 *C.char       // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(tooltip)))
	defer C.free(unsafe.Pointer(_arg1))

	C.adw_tab_page_set_indicator_tooltip(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(tooltip)
}

// SetKeyword sets the search keyword for self.
//
// taboverview can search pages by their keywords in addition to their titles
// and tooltips.
//
// Keywords allow to include e.g. page URLs into tab search in a web browser.
//
// The function takes the following parameters:
//
//   - keyword: search keyword.
func (self *TabPage) SetKeyword(keyword string) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 *C.char       // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(keyword)))
	defer C.free(unsafe.Pointer(_arg1))

	C.adw_tab_page_set_keyword(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(keyword)
}

// SetLiveThumbnail sets whether to enable live thumbnail for self.
//
// When set to TRUE, self's thumbnail in taboverview will update immediately
// when self is redrawn or resized.
//
// If it's set to FALSE, the thumbnail will only be live when the self
// is selected, and otherwise it will be static and will only update when
// tabpage.InvalidateThumbnail or tabview.InvalidateThumbnails is called.
//
// The function takes the following parameters:
//
//   - liveThumbnail: whether to enable live thumbnail.
func (self *TabPage) SetLiveThumbnail(liveThumbnail bool) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if liveThumbnail {
		_arg1 = C.TRUE
	}

	C.adw_tab_page_set_live_thumbnail(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(liveThumbnail)
}

// SetLoading sets whether self is loading.
//
// If set to TRUE, tabbar and taboverview will display a spinner in place of
// icon.
//
// If the page is pinned and tabpage:indicator-icon is set, loading status will
// not be visible with AdwTabBar.
//
// The function takes the following parameters:
//
//   - loading: whether self is loading.
func (self *TabPage) SetLoading(loading bool) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if loading {
		_arg1 = C.TRUE
	}

	C.adw_tab_page_set_loading(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(loading)
}

// SetNeedsAttention sets whether self needs attention.
//
// tabbar will display a line under the tab representing the page if set to
// TRUE. If the tab is not visible, the corresponding edge of the tab bar will
// be highlighted.
//
// taboverview will display a dot in the corner of the thumbnail if set to TRUE.
//
// tabbutton will display a dot if any of the pages that aren't selected have
// tabpage:needs-attention set to TRUE.
//
// The function takes the following parameters:
//
//   - needsAttention: whether self needs attention.
func (self *TabPage) SetNeedsAttention(needsAttention bool) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if needsAttention {
		_arg1 = C.TRUE
	}

	C.adw_tab_page_set_needs_attention(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(needsAttention)
}

// SetThumbnailXAlign sets the horizontal alignment of the thumbnail for self.
//
// If the page is so wide that taboverview can't display it completely and has
// to crop it, horizontal alignment will determine which part of the page will
// be visible.
//
// For example, 0.5 means the center of the page will be visible, 0 means the
// start edge will be visible and 1 means the end edge will be visible.
//
// The default horizontal alignment is 0.
//
// The function takes the following parameters:
//
//   - xalign: new value.
func (self *TabPage) SetThumbnailXAlign(xalign float32) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 C.float       // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.float(xalign)

	C.adw_tab_page_set_thumbnail_xalign(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(xalign)
}

// SetThumbnailYAlign sets the vertical alignment of the thumbnail for self.
//
// If the page is so tall that taboverview can't display it completely and has
// to crop it, vertical alignment will determine which part of the page will be
// visible.
//
// For example, 0.5 means the center of the page will be visible, 0 means the
// top edge will be visible and 1 means the bottom edge will be visible.
//
// The default vertical alignment is 0.
//
// The function takes the following parameters:
//
//   - yalign: new value.
func (self *TabPage) SetThumbnailYAlign(yalign float32) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 C.float       // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.float(yalign)

	C.adw_tab_page_set_thumbnail_yalign(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(yalign)
}

// SetTitle: tabbar will display it in the center of the tab unless it's pinned,
// and will use it as a tooltip unless tabpage:tooltip is set.
//
// taboverview will display it below the thumbnail unless it's pinned, or inside
// the card otherwise, and will use it as a tooltip unless tabpage:tooltip is
// set.
//
// Sets the title of self.
//
// The function takes the following parameters:
//
//   - title of self.
func (self *TabPage) SetTitle(title string) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 *C.char       // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	C.adw_tab_page_set_title(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(title)
}

// SetTooltip sets the tooltip of self.
//
// The tooltip can be marked up with the Pango text markup language.
//
// If not set, tabbar and taboverview will use tabpage:title as a tooltip
// instead.
//
// The function takes the following parameters:
//
//   - tooltip of self.
func (self *TabPage) SetTooltip(tooltip string) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 *C.char       // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(tooltip)))
	defer C.free(unsafe.Pointer(_arg1))

	C.adw_tab_page_set_tooltip(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(tooltip)
}

// TabViewOverrides contains methods that are overridable.
type TabViewOverrides struct {
}

func defaultTabViewOverrides(v *TabView) TabViewOverrides {
	return TabViewOverrides{}
}

// TabView: dynamic tabbed container.
//
// AdwTabView is a container which shows one child at a time. While it provides
// keyboard shortcuts for switching between pages, it does not provide a
// visible tab switcher and relies on external widgets for that, such as tabbar,
// taboverview and tabbutton.
//
// AdwTabView maintains a tabpage object for each page, which holds additional
// per-page properties. You can obtain the AdwTabPage for a page with
// tabview.GetPage, and as the return value for tabview.Append and other
// functions for adding children.
//
// AdwTabView only aims to be useful for dynamic tabs in multi-window
// document-based applications, such as web browsers, file managers, text
// editors or terminals. It does not aim to replace gtk.Notebook for use cases
// such as tabbed dialogs.
//
// As such, it does not support disabling page reordering or detaching.
//
// AdwTabView adds a number of global page switching and reordering shortcuts.
// The tabview:shortcuts property can be used to manage them.
//
// See tabviewshortcuts for the list of the available shortcuts. All of the
// shortcuts are enabled by default.
//
// tabview.AddShortcuts and tabview.RemoveShortcuts can be used to manage
// shortcuts in a convenient way, for example:
//
//	adw_tab_view_remove_shortcuts (view, ADW_TAB_VIEW_SHORTCUT_CONTROL_HOME |
//	                                     ADW_TAB_VIEW_SHORTCUT_CONTROL_END);
//
// # CSS nodes
//
// AdwTabView has a main CSS node with the name tabview.
//
// # Accessibility
//
// AdwTabView uses the GTK_ACCESSIBLE_ROLE_TAB_PANEL for the tab pages which are
// the accessible parent objects of the child widgets.
type TabView struct {
	_ [0]func() // equal guard
	gtk.Widget
}

var (
	_ gtk.Widgetter = (*TabView)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TabView, *TabViewClass, TabViewOverrides](
		GTypeTabView,
		initTabViewClass,
		wrapTabView,
		defaultTabViewOverrides,
	)
}

func initTabViewClass(gclass unsafe.Pointer, overrides TabViewOverrides, classInitFunc func(*TabViewClass)) {
	if classInitFunc != nil {
		class := (*TabViewClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTabView(obj *coreglib.Object) *TabView {
	return &TabView{
		Widget: gtk.Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: gtk.Accessible{
				Object: obj,
			},
			Buildable: gtk.Buildable{
				Object: obj,
			},
			ConstraintTarget: gtk.ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalTabView(p uintptr) (interface{}, error) {
	return wrapTabView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectClosePage is emitted after tabview.ClosePage has been called for page.
//
// The handler is expected to call tabview.ClosePageFinish to confirm or reject
// the closing.
//
// The default handler will immediately confirm closing for non-pinned pages,
// or reject it for pinned pages, equivalent to the following example:
//
//	static gboolean
//	close_page_cb (AdwTabView *view,
//	               AdwTabPage *page,
//	               gpointer    user_data)
//	{
//	  adw_tab_view_close_page_finish (view, page, !adw_tab_page_get_pinned (page));
//
//	  return GDK_EVENT_STOP;
//	}
//
// The tabview.ClosePageFinish call doesn't have to happen inside the handler,
// so can be used to do asynchronous checks before confirming the closing.
//
// A typical reason to connect to this signal is to show a confirmation dialog
// for closing a tab.
//
// The signal handler should return GDK_EVENT_STOP to stop propagation or
// GDK_EVENT_CONTINUE to invoke the default handler.
func (self *TabView) ConnectClosePage(f func(page *TabPage) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "close-page", false, unsafe.Pointer(C._gotk4_adw1_TabView_ConnectClosePage), f)
}

// ConnectCreateWindow is emitted when a tab should be transferred into a new
// window.
//
// This can happen after a tab has been dropped on desktop.
//
// The signal handler is expected to create a new window, position it as needed
// and return its AdwTabView that the page will be transferred into.
func (self *TabView) ConnectCreateWindow(f func() (tabView *TabView)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "create-window", false, unsafe.Pointer(C._gotk4_adw1_TabView_ConnectCreateWindow), f)
}

// ConnectIndicatorActivated is emitted after the indicator icon on page has
// been activated.
//
// See tabpage:indicator-icon and tabpage:indicator-activatable.
func (self *TabView) ConnectIndicatorActivated(f func(page *TabPage)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "indicator-activated", false, unsafe.Pointer(C._gotk4_adw1_TabView_ConnectIndicatorActivated), f)
}

// ConnectPageAttached is emitted when a page has been created or transferred to
// self.
//
// A typical reason to connect to this signal would be to connect to page
// signals for things such as updating window title.
func (self *TabView) ConnectPageAttached(f func(page *TabPage, position int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "page-attached", false, unsafe.Pointer(C._gotk4_adw1_TabView_ConnectPageAttached), f)
}

// ConnectPageDetached is emitted when a page has been removed or transferred to
// another view.
//
// A typical reason to connect to this signal would be to disconnect signal
// handlers connected in the tabview::page-attached handler.
//
// It is important not to try and destroy the page child in the handler of this
// function as the child might merely be moved to another window; use child
// dispose handler for that or do it in sync with your tabview.ClosePageFinish
// calls.
func (self *TabView) ConnectPageDetached(f func(page *TabPage, position int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "page-detached", false, unsafe.Pointer(C._gotk4_adw1_TabView_ConnectPageDetached), f)
}

// ConnectPageReordered is emitted after page has been reordered to position.
func (self *TabView) ConnectPageReordered(f func(page *TabPage, position int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "page-reordered", false, unsafe.Pointer(C._gotk4_adw1_TabView_ConnectPageReordered), f)
}

// ConnectSetupMenu is emitted when a context menu is opened or closed for page.
//
// If the menu has been closed, page will be set to NULL.
//
// It can be used to set up menu actions before showing the menu, for example
// disable actions not applicable to page.
func (self *TabView) ConnectSetupMenu(f func(page *TabPage)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "setup-menu", false, unsafe.Pointer(C._gotk4_adw1_TabView_ConnectSetupMenu), f)
}

// NewTabView creates a new AdwTabView.
//
// The function returns the following values:
//
//   - tabView: newly created AdwTabView.
func NewTabView() *TabView {
	var _cret *C.AdwTabView // in

	_cret = C.adw_tab_view_new()

	var _tabView *TabView // out

	_tabView = wrapTabView(coreglib.Take(unsafe.Pointer(_cret)))

	return _tabView
}

// AddPage adds child to self with parent as the parent.
//
// This function can be used to automatically position new pages, and to
// select the correct page when this page is closed while being selected (see
// tabview.ClosePage).
//
// If parent is NULL, this function is equivalent to tabview.Append.
//
// The function takes the following parameters:
//
//   - child: widget to add.
//   - parent (optional) page for child.
//
// The function returns the following values:
//
//   - tabPage: page object representing child.
func (self *TabView) AddPage(child gtk.Widgetter, parent *TabPage) *TabPage {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 *C.AdwTabPage // out
	var _cret *C.AdwTabPage // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if parent != nil {
		_arg2 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	_cret = C.adw_tab_view_add_page(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
	runtime.KeepAlive(parent)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// AddShortcuts adds shortcuts for self.
//
// See tabview:shortcuts for details.
//
// The function takes the following parameters:
//
//   - shortcuts to add.
func (self *TabView) AddShortcuts(shortcuts TabViewShortcuts) {
	var _arg0 *C.AdwTabView         // out
	var _arg1 C.AdwTabViewShortcuts // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwTabViewShortcuts(shortcuts)

	C.adw_tab_view_add_shortcuts(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(shortcuts)
}

// Append inserts child as the last non-pinned page.
//
// The function takes the following parameters:
//
//   - child: widget to add.
//
// The function returns the following values:
//
//   - tabPage: page object representing child.
func (self *TabView) Append(child gtk.Widgetter) *TabPage {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.GtkWidget  // out
	var _cret *C.AdwTabPage // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.adw_tab_view_append(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// AppendPinned inserts child as the last pinned page.
//
// The function takes the following parameters:
//
//   - child: widget to add.
//
// The function returns the following values:
//
//   - tabPage: page object representing child.
func (self *TabView) AppendPinned(child gtk.Widgetter) *TabPage {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.GtkWidget  // out
	var _cret *C.AdwTabPage // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.adw_tab_view_append_pinned(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// CloseOtherPages requests to close all pages other than page.
//
// The function takes the following parameters:
//
//   - page of self.
func (self *TabView) CloseOtherPages(page *TabPage) {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	C.adw_tab_view_close_other_pages(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
}

// ClosePage requests to close page.
//
// Calling this function will result in the tabview::close-page signal being
// emitted for page. Closing the page can then be confirmed or denied via
// tabview.ClosePageFinish.
//
// If the page is waiting for a tabview.ClosePageFinish call, this function will
// do nothing.
//
// The default handler for tabview::close-page will immediately confirm closing
// the page if it's non-pinned, or reject it if it's pinned. This behavior can
// be changed by registering your own handler for that signal.
//
// If page was selected, another page will be selected instead:
//
// If the tabpage:parent value is NULL, the next page will be selected when
// possible, or if the page was already last, the previous page will be selected
// instead.
//
// If it's not NULL, the previous page will be selected if it's a descendant
// (possibly indirect) of the parent. If both the previous page and the parent
// are pinned, the parent will be selected instead.
//
// The function takes the following parameters:
//
//   - page of self.
func (self *TabView) ClosePage(page *TabPage) {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	C.adw_tab_view_close_page(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
}

// ClosePageFinish completes a tabview.ClosePage call for page.
//
// If confirm is TRUE, page will be closed. If it's FALSE, it will be reverted
// to its previous state and tabview.ClosePage can be called for it again.
//
// This function should not be called unless a custom handler for
// tabview::close-page is used.
//
// The function takes the following parameters:
//
//   - page of self.
//   - confirm: whether to confirm or deny closing page.
func (self *TabView) ClosePageFinish(page *TabPage, confirm bool) {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))
	if confirm {
		_arg2 = C.TRUE
	}

	C.adw_tab_view_close_page_finish(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
	runtime.KeepAlive(confirm)
}

// ClosePagesAfter requests to close all pages after page.
//
// The function takes the following parameters:
//
//   - page of self.
func (self *TabView) ClosePagesAfter(page *TabPage) {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	C.adw_tab_view_close_pages_after(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
}

// ClosePagesBefore requests to close all pages before page.
//
// The function takes the following parameters:
//
//   - page of self.
func (self *TabView) ClosePagesBefore(page *TabPage) {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	C.adw_tab_view_close_pages_before(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
}

// DefaultIcon gets the default icon of self.
//
// The function returns the following values:
//
//   - icon: default icon of self.
func (self *TabView) DefaultIcon() *gio.Icon {
	var _arg0 *C.AdwTabView // out
	var _cret *C.GIcon      // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_view_get_default_icon(_arg0)
	runtime.KeepAlive(self)

	var _icon *gio.Icon // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_icon = &gio.Icon{
			Object: obj,
		}
	}

	return _icon
}

// IsTransferringPage: whether a page is being transferred.
//
// The corresponding property will be set to TRUE when a drag-n-drop tab
// transfer starts on any AdwTabView, and to FALSE after it ends.
//
// During the transfer, children cannot receive pointer input and a tab can be
// safely dropped on the tab view.
//
// The function returns the following values:
//
//   - ok: whether a page is being transferred.
func (self *TabView) IsTransferringPage() bool {
	var _arg0 *C.AdwTabView // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_view_get_is_transferring_page(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MenuModel gets the tab context menu model for self.
//
// The function returns the following values:
//
//   - menuModel (optional): tab context menu model for self.
func (self *TabView) MenuModel() gio.MenuModeller {
	var _arg0 *C.AdwTabView // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_view_get_menu_model(_arg0)
	runtime.KeepAlive(self)

	var _menuModel gio.MenuModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.MenuModeller)
				return ok
			})
			rv, ok := casted.(gio.MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// NPages gets the number of pages in self.
//
// The function returns the following values:
//
//   - gint: number of pages in self.
func (self *TabView) NPages() int {
	var _arg0 *C.AdwTabView // out
	var _cret C.int         // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_view_get_n_pages(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NPinnedPages gets the number of pinned pages in self.
//
// See tabview.SetPagePinned.
//
// The function returns the following values:
//
//   - gint: number of pinned pages in self.
func (self *TabView) NPinnedPages() int {
	var _arg0 *C.AdwTabView // out
	var _cret C.int         // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_view_get_n_pinned_pages(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NthPage gets the tabpage representing the child at position.
//
// The function takes the following parameters:
//
//   - position: index of the page in self, starting from 0.
//
// The function returns the following values:
//
//   - tabPage: page object at position.
func (self *TabView) NthPage(position int) *TabPage {
	var _arg0 *C.AdwTabView // out
	var _arg1 C.int         // out
	var _cret *C.AdwTabPage // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(position)

	_cret = C.adw_tab_view_get_nth_page(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// Page gets the tabpage object representing child.
//
// The function takes the following parameters:
//
//   - child in self.
//
// The function returns the following values:
//
//   - tabPage: page object for child.
func (self *TabView) Page(child gtk.Widgetter) *TabPage {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.GtkWidget  // out
	var _cret *C.AdwTabPage // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.adw_tab_view_get_page(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// PagePosition finds the position of page in self, starting from 0.
//
// The function takes the following parameters:
//
//   - page of self.
//
// The function returns the following values:
//
//   - gint: position of page in self.
func (self *TabView) PagePosition(page *TabPage) int {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out
	var _cret C.int         // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	_cret = C.adw_tab_view_get_page_position(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Pages returns a gio.ListModel that contains the pages of self.
//
// This can be used to keep an up-to-date view. The model also implements
// gtk.SelectionModel and can be used to track and change the selected page.
//
// The function returns the following values:
//
//   - selectionModel: GtkSelectionModel for the pages of self.
func (self *TabView) Pages() *gtk.SelectionModel {
	var _arg0 *C.AdwTabView        // out
	var _cret *C.GtkSelectionModel // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_view_get_pages(_arg0)
	runtime.KeepAlive(self)

	var _selectionModel *gtk.SelectionModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_selectionModel = &gtk.SelectionModel{
			ListModel: gio.ListModel{
				Object: obj,
			},
		}
	}

	return _selectionModel
}

// SelectedPage gets the currently selected page in self.
//
// The function returns the following values:
//
//   - tabPage (optional): selected page.
func (self *TabView) SelectedPage() *TabPage {
	var _arg0 *C.AdwTabView // out
	var _cret *C.AdwTabPage // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_view_get_selected_page(_arg0)
	runtime.KeepAlive(self)

	var _tabPage *TabPage // out

	if _cret != nil {
		_tabPage = wrapTabPage(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _tabPage
}

// Shortcuts gets the enabled shortcuts for self.
//
// The function returns the following values:
//
//   - tabViewShortcuts: shortcut mask.
func (self *TabView) Shortcuts() TabViewShortcuts {
	var _arg0 *C.AdwTabView         // out
	var _cret C.AdwTabViewShortcuts // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_view_get_shortcuts(_arg0)
	runtime.KeepAlive(self)

	var _tabViewShortcuts TabViewShortcuts // out

	_tabViewShortcuts = TabViewShortcuts(_cret)

	return _tabViewShortcuts
}

// Insert inserts a non-pinned page at position.
//
// It's an error to try to insert a page before a pinned page, in that case
// tabview.InsertPinned should be used instead.
//
// The function takes the following parameters:
//
//   - child: widget to add.
//   - position to add child at, starting from 0.
//
// The function returns the following values:
//
//   - tabPage: page object representing child.
func (self *TabView) Insert(child gtk.Widgetter, position int) *TabPage {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.int         // out
	var _cret *C.AdwTabPage // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.int(position)

	_cret = C.adw_tab_view_insert(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
	runtime.KeepAlive(position)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// InsertPinned inserts a pinned page at position.
//
// It's an error to try to insert a pinned page after a non-pinned page, in that
// case tabview.Insert should be used instead.
//
// The function takes the following parameters:
//
//   - child: widget to add.
//   - position to add child at, starting from 0.
//
// The function returns the following values:
//
//   - tabPage: page object representing child.
func (self *TabView) InsertPinned(child gtk.Widgetter, position int) *TabPage {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.int         // out
	var _cret *C.AdwTabPage // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.int(position)

	_cret = C.adw_tab_view_insert_pinned(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
	runtime.KeepAlive(position)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// InvalidateThumbnails invalidates thumbnails for all pages in self.
//
// This is a convenience method, equivalent to calling
// tabpage.InvalidateThumbnail on each page.
func (self *TabView) InvalidateThumbnails() {
	var _arg0 *C.AdwTabView // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.adw_tab_view_invalidate_thumbnails(_arg0)
	runtime.KeepAlive(self)
}

// Prepend inserts child as the first non-pinned page.
//
// The function takes the following parameters:
//
//   - child: widget to add.
//
// The function returns the following values:
//
//   - tabPage: page object representing child.
func (self *TabView) Prepend(child gtk.Widgetter) *TabPage {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.GtkWidget  // out
	var _cret *C.AdwTabPage // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.adw_tab_view_prepend(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// PrependPinned inserts child as the first pinned page.
//
// The function takes the following parameters:
//
//   - child: widget to add.
//
// The function returns the following values:
//
//   - tabPage: page object representing child.
func (self *TabView) PrependPinned(child gtk.Widgetter) *TabPage {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.GtkWidget  // out
	var _cret *C.AdwTabPage // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.adw_tab_view_prepend_pinned(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)

	var _tabPage *TabPage // out

	_tabPage = wrapTabPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _tabPage
}

// RemoveShortcuts removes shortcuts from self.
//
// See tabview:shortcuts for details.
//
// The function takes the following parameters:
//
//   - shortcuts to reomve.
func (self *TabView) RemoveShortcuts(shortcuts TabViewShortcuts) {
	var _arg0 *C.AdwTabView         // out
	var _arg1 C.AdwTabViewShortcuts // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwTabViewShortcuts(shortcuts)

	C.adw_tab_view_remove_shortcuts(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(shortcuts)
}

// ReorderBackward reorders page to before its previous page if possible.
//
// The function takes the following parameters:
//
//   - page of self.
//
// The function returns the following values:
//
//   - ok: whether page was moved.
func (self *TabView) ReorderBackward(page *TabPage) bool {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	_cret = C.adw_tab_view_reorder_backward(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReorderFirst reorders page to the first possible position.
//
// The function takes the following parameters:
//
//   - page of self.
//
// The function returns the following values:
//
//   - ok: whether page was moved.
func (self *TabView) ReorderFirst(page *TabPage) bool {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	_cret = C.adw_tab_view_reorder_first(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReorderForward reorders page to after its next page if possible.
//
// The function takes the following parameters:
//
//   - page of self.
//
// The function returns the following values:
//
//   - ok: whether page was moved.
func (self *TabView) ReorderForward(page *TabPage) bool {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	_cret = C.adw_tab_view_reorder_forward(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReorderLast reorders page to the last possible position.
//
// The function takes the following parameters:
//
//   - page of self.
//
// The function returns the following values:
//
//   - ok: whether page was moved.
func (self *TabView) ReorderLast(page *TabPage) bool {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	_cret = C.adw_tab_view_reorder_last(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReorderPage reorders page to position.
//
// It's a programmer error to try to reorder a pinned page after a non-pinned
// one, or a non-pinned page before a pinned one.
//
// The function takes the following parameters:
//
//   - page of self.
//   - position to insert the page at, starting at 0.
//
// The function returns the following values:
//
//   - ok: whether page was moved.
func (self *TabView) ReorderPage(page *TabPage, position int) bool {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out
	var _arg2 C.int         // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))
	_arg2 = C.int(position)

	_cret = C.adw_tab_view_reorder_page(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
	runtime.KeepAlive(position)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectNextPage selects the page after the currently selected page.
//
// If the last page was already selected, this function does nothing.
//
// The function returns the following values:
//
//   - ok: whether the selected page was changed.
func (self *TabView) SelectNextPage() bool {
	var _arg0 *C.AdwTabView // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_view_select_next_page(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectPreviousPage selects the page before the currently selected page.
//
// If the first page was already selected, this function does nothing.
//
// The function returns the following values:
//
//   - ok: whether the selected page was changed.
func (self *TabView) SelectPreviousPage() bool {
	var _arg0 *C.AdwTabView // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_view_select_previous_page(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDefaultIcon sets the default page icon for self.
//
// If a page doesn't provide its own icon via tabpage:icon, a default icon may
// be used instead for contexts where having an icon is necessary.
//
// tabbar will use default icon for pinned tabs in case the page is not loading,
// doesn't have an icon and an indicator. Default icon is never used for tabs
// that aren't pinned.
//
// taboverview will use default icon for pages with missing thumbnails.
//
// By default, the adw-tab-icon-missing-symbolic icon is used.
//
// The function takes the following parameters:
//
//   - defaultIcon: default icon.
func (self *TabView) SetDefaultIcon(defaultIcon gio.Iconner) {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.GIcon      // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(defaultIcon).Native()))

	C.adw_tab_view_set_default_icon(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(defaultIcon)
}

// SetMenuModel sets the tab context menu model for self.
//
// When a context menu is shown for a tab, it will be constructed from the
// provided menu model. Use the tabview::setup-menu signal to set up the menu
// actions for the particular tab.
//
// The function takes the following parameters:
//
//   - menuModel (optional): menu model.
func (self *TabView) SetMenuModel(menuModel gio.MenuModeller) {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if menuModel != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(menuModel).Native()))
	}

	C.adw_tab_view_set_menu_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(menuModel)
}

// SetPagePinned pins or unpins page.
//
// Pinned pages are guaranteed to be placed before all non-pinned pages; at any
// given moment the first tabview:n-pinned-pages pages in self are guaranteed to
// be pinned.
//
// When a page is pinned or unpinned, it's automatically reordered: pinning a
// page moves it after other pinned pages; unpinning a page moves it before
// other non-pinned pages.
//
// Pinned pages can still be reordered between each other.
//
// tabbar will display pinned pages in a compact form, never showing the title
// or close button, and only showing a single icon, selected in the following
// order:
//
// 1. tabpage:indicator-icon 2. A spinner if tabpage:loading is TRUE 3.
// tabpage:icon 4. tabview:default-icon
//
// taboverview will not show a thumbnail for pinned pages, and replace the close
// button with an unpin button. Unlike AdwTabBar, it will still display the
// page's title, icon and indicator separately.
//
// Pinned pages cannot be closed by default, see tabview::close-page for how to
// override that behavior.
//
// Changes the value of the tabpage:pinned property.
//
// The function takes the following parameters:
//
//   - page of self.
//   - pinned: whether page should be pinned.
func (self *TabView) SetPagePinned(page *TabPage, pinned bool) {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))
	if pinned {
		_arg2 = C.TRUE
	}

	C.adw_tab_view_set_page_pinned(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
	runtime.KeepAlive(pinned)
}

// SetSelectedPage sets the currently selected page in self.
//
// The function takes the following parameters:
//
//   - selectedPage: page in self.
func (self *TabView) SetSelectedPage(selectedPage *TabPage) {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(selectedPage).Native()))

	C.adw_tab_view_set_selected_page(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(selectedPage)
}

// SetShortcuts sets the enabled shortcuts for self.
//
// See tabviewshortcuts for the list of the available shortcuts. All of the
// shortcuts are enabled by default.
//
// tabview.AddShortcuts and tabview.RemoveShortcuts provide a convenient way to
// manage individual shortcuts.
//
// The function takes the following parameters:
//
//   - shortcuts: new shortcuts.
func (self *TabView) SetShortcuts(shortcuts TabViewShortcuts) {
	var _arg0 *C.AdwTabView         // out
	var _arg1 C.AdwTabViewShortcuts // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwTabViewShortcuts(shortcuts)

	C.adw_tab_view_set_shortcuts(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(shortcuts)
}

// TransferPage transfers page from self to other_view.
//
// The page object will be reused.
//
// It's a programmer error to try to insert a pinned page after a non-pinned
// one, or a non-pinned page before a pinned one.
//
// The function takes the following parameters:
//
//   - page of self.
//   - otherView: tab view to transfer the page to.
//   - position to insert the page at, starting at 0.
func (self *TabView) TransferPage(page *TabPage, otherView *TabView, position int) {
	var _arg0 *C.AdwTabView // out
	var _arg1 *C.AdwTabPage // out
	var _arg2 *C.AdwTabView // out
	var _arg3 C.int         // out

	_arg0 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))
	_arg2 = (*C.AdwTabView)(unsafe.Pointer(coreglib.InternObject(otherView).Native()))
	_arg3 = C.int(position)

	C.adw_tab_view_transfer_page(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(page)
	runtime.KeepAlive(otherView)
	runtime.KeepAlive(position)
}

// TabPageClass: instance of this type is always passed by reference.
type TabPageClass struct {
	*tabPageClass
}

// tabPageClass is the struct that's finalized.
type tabPageClass struct {
	native *C.AdwTabPageClass
}

// TabViewClass: instance of this type is always passed by reference.
type TabViewClass struct {
	*tabViewClass
}

// tabViewClass is the struct that's finalized.
type tabViewClass struct {
	native *C.AdwTabViewClass
}

func (t *TabViewClass) ParentClass() *gtk.WidgetClass {
	valptr := &t.native.parent_class
	var _v *gtk.WidgetClass // out
	_v = (*gtk.WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
